#include <QGuiApplication>
#include <QQmlApplicationEngine>

int main(int argc, char *argv[])
{
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
#endif

    QGuiApplication app(argc, argv);

    QQmlApplicationEngine engine;                                               //Создание объекта движка/интерпретатора QML
    const QUrl url(QStringLiteral("qrc:/main.qml"));                            //Задание файла QML-разметки для стартовой страницы для приложения

    //Конструкция ниже задаёт связь между событием "objectCreated" объекта "Engine" и коллбеком
    QObject::connect(&engine, &QQmlApplicationEngine::objectCreated,
                     &app,
                     [url](QObject *obj, const QUrl &objUrl) {                  //Лямбда-выражение, то есть, безымянная функция
                        if (!obj && url == objUrl) QCoreApplication::exit(-1);  //Действие на случай ошибки внутри движка (кривой скрипт)
                      }, Qt::QueuedConnection);

    engine.load(url);                                                           //Загрузить файл стартовой страницы в движок

    return app.exec();                                                          //Начало работы приложения, то есть передача управления от точки входа коду самого приложения (cpp и qml)
}

// строение проекта
/*.pro - файл настроек системы сборки qmake, все файлы из дерева
проекта перечислены в этом файле, при удалении из pro файла удаляются из дерева

- все файлы из дерева проекта
- внешние библиотеки (.lib и .h-файлы) подключаются через *.pro
- различие процесса сборки для ОС задается в .pro

/main.cpp - точка входа в приложение. А в случае приложения в QML
в main создается объект движка-интерпретатора QML-разметки

Как и в любом C++ приложении, в проекте могут быть другие cpp и h файлы

Описание интерфейса приложения и простейших механик его логики
содержится в файлах QML, которые выполняют роль фронтенда
QML - диалект JS + JSON

.qrc - файл ресурсов, туда помещаются любые некомпилируемые данные
изображения, 3D-сетки, аудио итд

Конфигурация Release - под приложения и ничего лишнего
Конфигурация Debug (Сборка) - больше по объему, чем Release, так как содержит встроенную информацию для
привязки полученного машинного кода к исходным строкам кода для возможности работать в отладчике
именно с исходным кодом

Сборка Debug больше (в 3 раза и более), медленнее и содержит информацию об исходном коде приложения
по которому злоумышленники могут провести реверс-инжиниринг
*/

//1 отладка QML кода и совместная отладка
/*
Отладка С++ кода производится обязательно в Debug (Сборка) и с запущенным отладчиком (F5 вместо Cmd+R)
кроме того, отладка С++ может производится печатью qDebug() « "Текст"; (не только в Debug, но и в Release)

Отладка QML кода также производится либо отладочной печатью (так быстрее) либо с запущенным отладчиком
*/

//2 раскладка по Layouts и Anchors
/*
Если на странице графических элементов немного, то можно выравнивать каждый элемент по границам соседнего:
button.bottom : label.top (пример) - дно кнопки будет выровнено по верхушке Label
button.left: label.right (пример)

Если элементов больше, их проще расположить в Layout по логике таблицы
Layout имеет ячейки (GridLayout и по вертикали, и по горизонтали; ColumnLayout только
по вертикали; RowLayout только по горизонтали)
*/
